import json
import logging
import subprocess
import tempfile

from uclid.builder import *

from .dsl import Expr, FalseExpr, TrueExpr
from .dsl_parser import str2Expr
from .utils import Result, parse_uclid_output


class Module:
    """
    Wrapper class for Uclid modules with procedures

    Attributes
    ----------
    procs : dict(str -> Procedure)
        Store procedure names and corresponding objects
    module : UclidModule
        Uclid module to be constructed
    delete : bool
        Delete temporary file after use (default = True)
    verbose : bool
        Log debug messages (default = False)
    use_cex_json : bool
        Parse counterexample from uclid json output (default = False)

    Methods
    -------
    getProcedures() -> dict
        Returns reference of `procs` object
    updateArtifact(name: str, requires: Expr, ensures: Expr) -> None
        Appends new pre/post-conditions to function `name`
    buildUclidModule() -> UclidModule
        Builds and returns Uclid module
    addProcedureCallStmt(proc: UclidProcedure, inputs: List[UclidExpr],
                         returns: List[UclidExpr]) -> UclidProcedureCallStmt
        Add procedure call statement to Uclid module
    verify() -> (Result, dict)
        Verify Uclid module using latest artifacts
        Returns result and cex if there is one
    parseResult() -> Result
        Parses result from stdout generated by Uclid
    loadPrePost(solution: dict) -> None
        Load pre/post-conditions from solution to avoid re-synthesis
    """

    verifier_exe = "uclid"
    cex_basename = "./cex"

    def __init__(self, name=None, delete=True, verbose=False, use_cex_json=False):
        self.procs = {}
        self.module = None
        self.name = name
        self.delete = delete
        self.verbose = verbose
        self.use_cex_json = use_cex_json
        # Logging
        self.logger = logging.getLogger("ModelChecker.ExtModule")
        self.logger.setLevel(logging.DEBUG if verbose else logging.INFO)
        # NOTE: Declare procedures here

    def getProcedures(self) -> dict:
        """Returns reference of `procs` object"""
        return self.procs

    def updateArtifact(
        self,
        name: str,
        requires: Expr,
        ensures: Expr,
    ) -> None:
        """
        Appends artifact to artifact history

        Parameters
        ----------
        name : str
            function name
        artifact : (str, str)
            requires/ensures pair to be appended
        """
        if name not in self.procs.keys():
            self.logger.warning(f"Procedure {name} not found")
        else:
            self.procs[name].requires.append(requires)
            self.procs[name].ensures.append(ensures)

    def buildUclidModule(self) -> UclidModule:
        """Builds and returns Uclid module"""
        # Build uclid module here
        raise NotImplementedError

    def addProcedureCallStmt(
        self, proc: UclidProcedure, inputs: List[UclidExpr], returns: List[UclidExpr]
    ):
        """
        Add procedure call statement to Uclid module
        Creates a UclidProcedureCallStmt object and adds to Procedure.invocations
        """
        stmt = UclidProcedureCallStmt(proc, inputs, returns)
        self.procs[stmt.iname].invocations.append(
            (
                [arg.__inject__() for arg in stmt.inputs],
                [ret.__inject__() for ret in stmt.returns],
            )
        )
        return stmt

    def verify(self):
        """
        Verify Uclid module using latest artifacts
        Returns result and cex if properties are violated
        """
        with tempfile.NamedTemporaryFile(
            prefix="uclid_", suffix=".ucl", mode="w+", delete=self.delete
        ) as f:
            self.module = self.buildUclidModule()
            f.write(self.module.__inject__())
            # Change file object's position to enable reading
            f.seek(0)
            self.logger.info(f"Uclid file written to {f.name}")

            self.logger.info(
                f"Read uclid result from {'json file' if self.use_cex_json else 'stdout'}"
            )
            if self.use_cex_json:
                cmd = f'{self.verifier_exe} -s "z3 -in" -j {self.cex_basename} {f.name}'
            else:
                cmd = f"{self.verifier_exe} {f.name}"
            self.logger.info(f"Running command: {cmd}")
            p = subprocess.Popen(
                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE
            )
            byte_output, _ = p.communicate()

        output = byte_output.decode("utf-8")
        if self.verbose:
            self.logger.debug(f"Uclid output: {output}")
        res = self.parseResult(output)
        self.logger.info(f"Uclid result: {res}")
        match res:
            case Result.PASSED:
                return res, None
            case Result.VIOLATED:
                if self.use_cex_json:
                    with open(self.cex_basename + ".json", "r") as f:
                        traces = json.load(f)
                    return res, traces
                else:
                    # Write output to a file named cex.log
                    filename = f"{self.cex_basename}.log"
                    with open(filename, "w") as f:
                        f.write(output)
                    # Parses cex from uclid stdout
                    traces = parse_uclid_output(filename)
                    return res, traces
            case Result.ERROR:
                raise RuntimeError(f"Error running command `{cmd}`\nOutput: {output}")
            case _:
                raise NotImplementedError(f"{res} not handled")

    def parseResult(self, output) -> Result:
        """Parses Uclid stdout"""
        lines = output.split("\n")
        if (
            len(lines) >= 4
            and "assertions" in lines[1]
            and "assertions" in lines[2]
            and "assertions" in lines[3]
        ):
            passed = int(lines[1].split()[0])
            violated = int(lines[2].split()[0])
            indeterminate = int(lines[3].split()[0])
            if passed >= 0 and violated == 0 and indeterminate == 0:
                return Result.PASSED
            else:
                return Result.VIOLATED
        return Result.ERROR

    def loadPrePost(self, solution):
        """Load pre/post-conditions to avoid re-synthesis"""
        for name, proc in self.procs.items():
            if name in solution:
                pre = str2Expr(solution[name]["dsl_pre"], proc.data)
                post = str2Expr(solution[name]["dsl_post"], proc.data)
                if pre == TrueExpr() and post == FalseExpr():
                    continue
                self.updateArtifact(name, pre, post)
                proc.synthesize = False
